--======= locals ===========local random = math.randomlocal tinsert = table.insertlocal floor = math.floorlocal CAMERA = CAMERAlocal GAME = GAMElocal Draw = love.graphics.drawlocal microtime = love.timer.getMicroTimelocal function DrawBucket(self)	if not self.complete then		return	end	-- draw the buffer if we have one or make one if we dont	if self.buffer then		love.graphics.draw(self.buffer, self.x-CAMERA.X, self.y-CAMERA.Y)		return	end	self.buffer = love.graphics.newCanvas(1024,1024)	love.graphics.setCanvas(self.buffer)	for i = 0, BUCKET_XCOUNT-1 do		for j = 0, BUCKET_YCOUNT-1 do			local tub = self:GetTub(i,j)			if tub and tub.oretype then				if not tub.img then					tub.img = love.graphics.newImage(tub.imgdata)				end				love.graphics.draw(tub.img, i*TUB_SIZE, j*TUB_SIZE)			end		end	end	if self.type then		love.graphics.print(self.type, 20,20)	end		love.graphics.setCanvas()	love.graphics.draw(self.buffer, self.x-CAMERA.X, self.y-CAMERA.Y) -- shoudl reduce flicker		--draw things that arent buffered 	for i = 1, #self.items do		self.items[i]:Draw(self.x-CAMERA.X,self.y-CAMERA.Y)	end	if self.creatures then		for i = 1, #self.creatures do			self.creatures[i]:Draw()		end	endendlocal function UpdateItems(self,dt,j)	for i = 1,#self.items do		local item = self.items[i]		if item then			if item:InPlayerRange(self.x+item.x,self.y+item.y) and not (#player.items == player.bagsize) then				if not item:Pickup(self.x+item.x,self.y+item.y,i,j) then					item:TweenToPlayer(self.x+item.x,self.y+item.y,dt)				end			else				local newy = item.y + item.vy*dt				if item:Collides(item.x, newy) then					item.vy = 0				else					item.vy = item.vy + GRAVITY*dt					item.y = newy				end			end		end	endendlocal function UpdateBucket(self,dt,j)	UpdateItems(self, dt,j)	if self.creatures then		for i = 1, #self.creatures do			if self.creatures[i] then				self.creatures[i]:Update(dt)			end		end	endendlocal function SetTub(self,tub, i, j)	if not self.tubs[i] then 		self.tubs[i] = {} 	end	self.tubs[i][j] = tubendlocal function FillBucket(self,a,depth, label)	local found		if label ~= "air" then		for i = 0, BUCKET_XCOUNT-1 do			for j = 0, BUCKET_YCOUNT-1 do				if (j*TUB_SIZE)+self.y > depth + World.Points[a][i+1] then					local tub = CreateBaseTexture(label,self,i,j)					self:SetTub(tub,i, j)					found = depth				end			end		end	end	return foundendlocal function GenerateLayers(b, i)	local oldlabel 	for j = 1, #SELECTED_WORLD.layers do		local config = SELECTED_WORLD.layers[j]		local dist = World.Points[i][1]+config.depth		if config.label then			local test = FillBucket(b,i,config.depth, config.label)			if not oldlabel and World.Points[i][1]+config.depth > b.y and World.Points[i][1]+config.depth < b.y+BUCKET_HEIGHT then				b.type = "surface"						end			if test then				oldlabel = test			end		end	endendlocal function CheckOres(b)	local depth = (World.Points[b.i][1]+World.Points[b.i+1][1])/2	for ore, info in pairs(SELECTED_WORLD.Ores) do		if b.y > info.mindepth+depth and b.y < info.maxdepth+depth then						if true then				local t = {}				for i = 0, BUCKET_XCOUNT-1 do					t[i] = {}				end												for a = 1, random(50) do					local x,y = random(0,BUCKET_XCOUNT), random(0,BUCKET_YCOUNT)					for i = 1, info.size-random(info.size) do						for j = 1, info.size-random(info.size) do							if t[i+x] and (y+j < BUCKET_YCOUNT) then								t[i+x][y+j] = true							end						end					end				end								for x = 0, BUCKET_XCOUNT-1 do					for y = 0, BUCKET_YCOUNT-1 do													local count = 0							for i = -1,1 do								for j = -1,1 do									if t[x+i] and t[x+i][y+j] then										count = count + 1									end								end							end																					if count < 5 then								t[x][y] = nil							elseif count > 6 then								t[x][y] = true							end					end									end									for x = 0, BUCKET_XCOUNT-1 do					for y = 0, BUCKET_YCOUNT-1 do						if t[x][y] then							b.tubs[x][y] = CreateBaseTexture(ore,b,x,y)						end					end				end							end				end	endendlocal function PlotHoles(b)endlocal function GetTub(self,x,y)	return self.tubs[x] and self.tubs[x][y]endfunction NewBucket(world,i,j)	if not CRASH_WHEN_GOING_TO_THE_LEFT and not World.Points[i] then		return 	end	local bucket = {tubs = {}, items = {}, SetTub = SetTub,								  Draw = DrawBucket,GetTub = GetTub, Update = UpdateBucket, i = i, j = j }		if not World.Buckets[i] then		World.Buckets[i] = {}	end	World.Buckets[i][j] = bucket		bucket.x = i*BUCKET_WIDTH 	bucket.y = j*BUCKET_HEIGHT 	GenerateLayers(bucket,i)	if bucket.type == "surface" then		bucket.creatures = {}		CheckCreatures(bucket)	end		CheckOres(bucket)		PlotHoles(bucket)	return bucketend